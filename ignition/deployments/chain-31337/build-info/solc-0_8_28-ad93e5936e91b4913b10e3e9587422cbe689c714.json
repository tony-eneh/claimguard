{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-ad93e5936e91b4913b10e3e9587422cbe689c714",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/AccessPolicyManager.sol": "project/contracts/AccessPolicyManager.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/AccessPolicyManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"./Types.sol\";\r\nimport \"./SubjectAttributeRegistry.sol\";\r\nimport \"./EvidenceRegistry.sol\";\r\n\r\n/// ------------------------------------------------------------------------\r\n/// Contract: AccessPolicyManager\r\n/// ------------------------------------------------------------------------\r\n\r\ncontract AccessPolicyManager {\r\n    address public admin;\r\n\r\n    SubjectAttributeRegistry public subjectRegistry;\r\n    EvidenceRegistry public evidenceRegistry;\r\n\r\n    uint256 public nextPolicyId = 1;\r\n    mapping(uint256 => PolicyRule) private _policies;\r\n\r\n    event AdminChanged(address indexed oldAdmin, address indexed newAdmin);\r\n\r\n    event PolicyCreated(\r\n        uint256 indexed policyId,\r\n        Role role,\r\n        bytes32 orgId,\r\n        bytes32 jurisdiction,\r\n        ResourceType rType,\r\n        bytes32 caseId,\r\n        Action action,\r\n        uint8 maxSensitivity,\r\n        uint64 notBefore,\r\n        uint64 notAfter,\r\n        bool allow\r\n    );\r\n\r\n    event PolicyRevoked(uint256 indexed policyId, address indexed by);\r\n\r\n    event AccessChecked(\r\n        address indexed subject,\r\n        uint256 indexed resourceId,\r\n        Action action,\r\n        bool allowed\r\n    );\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"PolicyMgr: only admin\");\r\n        _;\r\n    }\r\n\r\n    constructor(address subjectRegistry_, address evidenceRegistry_) {\r\n        require(subjectRegistry_ != address(0), \"PolicyMgr: subj reg zero\");\r\n        require(evidenceRegistry_ != address(0), \"PolicyMgr: evid reg zero\");\r\n\r\n        admin = msg.sender;\r\n        emit AdminChanged(address(0), msg.sender);\r\n\r\n        subjectRegistry = SubjectAttributeRegistry(subjectRegistry_);\r\n        evidenceRegistry = EvidenceRegistry(evidenceRegistry_);\r\n    }\r\n\r\n    function setAdmin(address newAdmin) external onlyAdmin {\r\n        require(newAdmin != address(0), \"PolicyMgr: zero addr\");\r\n        emit AdminChanged(admin, newAdmin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    /// @notice Create a new policy rule.\r\n    function createPolicy(\r\n        Role role,\r\n        bytes32 orgId,\r\n        bytes32 jurisdiction,\r\n        ResourceType rType,\r\n        bytes32 caseId,\r\n        Action action,\r\n        uint8 maxSensitivity,\r\n        uint64 notBefore,\r\n        uint64 notAfter,\r\n        bool allow\r\n    ) external onlyAdmin returns (uint256 policyId) {\r\n        require(role != Role.NONE, \"PolicyMgr: role=NONE\");\r\n        if (notAfter != 0) {\r\n            require(notAfter > notBefore, \"PolicyMgr: time window invalid\");\r\n        }\r\n\r\n        policyId = nextPolicyId++;\r\n        PolicyRule storage p = _policies[policyId];\r\n\r\n        p.id           = policyId;\r\n        p.role         = role;\r\n        p.orgId        = orgId;\r\n        p.jurisdiction = jurisdiction;\r\n        p.rType        = rType;\r\n        p.caseId       = caseId;\r\n        p.action       = action;\r\n        p.maxSensitivity = maxSensitivity;\r\n        p.notBefore    = notBefore;\r\n        p.notAfter     = notAfter;\r\n        p.allow        = allow;\r\n        p.active       = true;\r\n\r\n        emit PolicyCreated(\r\n            policyId,\r\n            role,\r\n            orgId,\r\n            jurisdiction,\r\n            rType,\r\n            caseId,\r\n            action,\r\n            maxSensitivity,\r\n            notBefore,\r\n            notAfter,\r\n            allow\r\n        );\r\n    }\r\n\r\n    /// @notice Deactivate a policy rule (revocation).\r\n    function revokePolicy(uint256 policyId) external onlyAdmin {\r\n        PolicyRule storage p = _policies[policyId];\r\n        require(p.id != 0, \"PolicyMgr: policy not found\");\r\n        require(p.active, \"PolicyMgr: already inactive\");\r\n        p.active = false;\r\n        emit PolicyRevoked(policyId, msg.sender);\r\n    }\r\n\r\n    /// @notice View a policy rule.\r\n    function getPolicy(uint256 policyId) external view returns (PolicyRule memory) {\r\n        return _policies[policyId];\r\n    }\r\n\r\n    /// @notice Core ABAC decision: can `subject` perform `action` on `resourceId`?\r\n    function checkAccess(\r\n        address subject,\r\n        uint256 resourceId,\r\n        Action action\r\n    ) public view returns (bool) {\r\n        // Load resource and subject attributes from the registries\r\n        Resource memory r = evidenceRegistry.getResource(resourceId);\r\n        if (!r.exists) {\r\n            return false;\r\n        }\r\n\r\n        SubjectAttrs memory s = subjectRegistry.getSubjectAttrs(subject);\r\n        if (!s.isActive || s.role == Role.NONE) {\r\n            return false;\r\n        }\r\n\r\n        // Linear scan over policies: 1..nextPolicyId-1\r\n        for (uint256 pid = 1; pid < nextPolicyId; pid++) {\r\n            PolicyRule storage p = _policies[pid];\r\n            if (!p.active || !p.allow) continue;\r\n\r\n            // Role must match.\r\n            if (p.role != s.role) continue;\r\n\r\n            // Optional org and jurisdiction constraints.\r\n            if (p.orgId != bytes32(0) && p.orgId != s.orgId) continue;\r\n            if (p.jurisdiction != bytes32(0) && p.jurisdiction != s.jurisdiction) continue;\r\n\r\n            // Resource type constraint (GENERIC serves as wildcard).\r\n            if (p.rType != ResourceType.GENERIC && p.rType != r.rType) continue;\r\n\r\n            // Case constraint (0 = any case).\r\n            if (p.caseId != bytes32(0) && p.caseId != r.caseId) continue;\r\n\r\n            // Action must match.\r\n            if (p.action != action) continue;\r\n\r\n            // Sensitivity constraint.\r\n            if (r.sensitivity > p.maxSensitivity) continue;\r\n\r\n            // Time window constraint.\r\n            uint64 nowTs = uint64(block.timestamp);\r\n            if (p.notBefore != 0 && nowTs < p.notBefore) continue;\r\n            if (p.notAfter  != 0 && nowTs > p.notAfter)  continue;\r\n\r\n            // First matching allow rule wins.\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @notice checkAccess + emit event for on-chain audit / off-chain listeners.\r\n    function checkAccessAndEmit(\r\n        address subject,\r\n        uint256 resourceId,\r\n        Action action\r\n    ) external returns (bool) {\r\n        bool allowed = checkAccess(subject, resourceId, action);\r\n        emit AccessChecked(subject, resourceId, action, allowed);\r\n        return allowed;\r\n    }\r\n}\r\n"
      },
      "project/contracts/EvidenceRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"./Types.sol\";\r\n\r\n/// ------------------------------------------------------------------------\r\n/// Contract: EvidenceRegistry\r\n/// ------------------------------------------------------------------------\r\n\r\ncontract EvidenceRegistry {\r\n    address public admin;\r\n\r\n    uint256 public nextResourceId = 1;\r\n\r\n    mapping(uint256 => Resource) private _resources;\r\n    mapping(bytes32 => uint256[]) private _resourcesByCase;\r\n\r\n    event AdminChanged(address indexed oldAdmin, address indexed newAdmin);\r\n\r\n    event ResourceRegistered(\r\n        uint256 indexed resourceId,\r\n        bytes32 indexed caseId,\r\n        ResourceType rType,\r\n        uint8 sensitivity,\r\n        address indexed owner,\r\n        bytes32 contentHash,\r\n        string uri\r\n    );\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"EvidenceReg: only admin\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        admin = msg.sender;\r\n        emit AdminChanged(address(0), msg.sender);\r\n    }\r\n\r\n    function setAdmin(address newAdmin) external onlyAdmin {\r\n        require(newAdmin != address(0), \"EvidenceReg: zero addr\");\r\n        emit AdminChanged(admin, newAdmin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    /// @notice Register a new resource/evidence object.\r\n    function registerResource(\r\n        bytes32 contentHash,\r\n        string calldata uri,\r\n        bytes32 caseId,\r\n        ResourceType rType,\r\n        uint8 sensitivity\r\n    ) external onlyAdmin returns (uint256 resourceId) {\r\n        require(contentHash != bytes32(0), \"EvidenceReg: empty hash\");\r\n\r\n        resourceId = nextResourceId++;\r\n        Resource storage r = _resources[resourceId];\r\n\r\n        r.id           = resourceId;\r\n        r.contentHash  = contentHash;\r\n        r.uri          = uri;\r\n        r.caseId       = caseId;\r\n        r.rType        = rType;\r\n        r.sensitivity  = sensitivity;\r\n        r.owner        = msg.sender;\r\n        r.exists       = true;\r\n\r\n        if (caseId != bytes32(0)) {\r\n            _resourcesByCase[caseId].push(resourceId);\r\n        }\r\n\r\n        emit ResourceRegistered(\r\n            resourceId,\r\n            caseId,\r\n            rType,\r\n            sensitivity,\r\n            msg.sender,\r\n            contentHash,\r\n            uri\r\n        );\r\n    }\r\n\r\n    /// @notice Get full resource metadata.\r\n    function getResource(uint256 resourceId) external view returns (Resource memory) {\r\n        return _resources[resourceId];\r\n    }\r\n\r\n    /// @notice Get all resource IDs associated with a case.\r\n    function getResourcesByCase(bytes32 caseId) external view returns (uint256[] memory) {\r\n        return _resourcesByCase[caseId];\r\n    }\r\n}\r\n"
      },
      "project/contracts/SubjectAttributeRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"./Types.sol\";\r\n\r\n/// ------------------------------------------------------------------------\r\n/// Contract: SubjectAttributeRegistry\r\n/// ------------------------------------------------------------------------\r\n\r\ncontract SubjectAttributeRegistry {\r\n    address public admin;\r\n\r\n    mapping(address => SubjectAttrs) private _subjects;\r\n\r\n    event AdminChanged(address indexed oldAdmin, address indexed newAdmin);\r\n\r\n    event SubjectAttributesSet(\r\n        address indexed subject,\r\n        Role role,\r\n        bytes32 orgId,\r\n        bytes32 jurisdiction,\r\n        bool isActive\r\n    );\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"SubjectAttr: only admin\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        admin = msg.sender;\r\n        emit AdminChanged(address(0), msg.sender);\r\n    }\r\n\r\n    function setAdmin(address newAdmin) external onlyAdmin {\r\n        require(newAdmin != address(0), \"SubjectAttr: zero addr\");\r\n        emit AdminChanged(admin, newAdmin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    /// @notice Set attributes for a subject (user, organization agent, etc.).\r\n    function setSubjectAttributes(\r\n        address subject,\r\n        Role role,\r\n        bytes32 orgId,\r\n        bytes32 jurisdiction,\r\n        bool isActive\r\n    ) external onlyAdmin {\r\n        _subjects[subject] = SubjectAttrs({\r\n            role: role,\r\n            orgId: orgId,\r\n            jurisdiction: jurisdiction,\r\n            isActive: isActive\r\n        });\r\n\r\n        emit SubjectAttributesSet(subject, role, orgId, jurisdiction, isActive);\r\n    }\r\n\r\n    /// @notice Get full attribute struct for a subject.\r\n    function getSubjectAttrs(address subject) external view returns (SubjectAttrs memory) {\r\n        return _subjects[subject];\r\n    }\r\n}\r\n"
      },
      "project/contracts/Types.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n/// ------------------------------------------------------------------------\r\n/// Shared Types for ClaimGuard\r\n/// ------------------------------------------------------------------------\r\n\r\n/// @dev High-level subject roles in the auto-insurance ecosystem.\r\nenum Role {\r\n    NONE,\r\n    DRIVER,\r\n    INSURER,\r\n    REINSURER,\r\n    ADJUSTER,\r\n    POLICE,\r\n    COURT,\r\n    GARAGE,\r\n    REGULATOR,\r\n    CLOUD_PROVIDER\r\n}\r\n\r\n/// @dev Generic resource types (FNOL, medical, PDF, video, logs, etc.).\r\nenum ResourceType {\r\n    GENERIC,\r\n    FNOL,\r\n    MEDICAL_REPORT,\r\n    REPAIR_ESTIMATE,\r\n    POLICE_REPORT,\r\n    IMAGE,\r\n    VIDEO,\r\n    PDF,\r\n    TELEMATICS,\r\n    LOG,\r\n    OTHER\r\n}\r\n\r\n/// @dev Actions that can be controlled by policies (CRUD + domain-specific).\r\nenum Action {\r\n    READ,       // view/download\r\n    APPEND,     // add new related evidence\r\n    UPDATE,     // change/annotate existing evidence\r\n    DELETE,     // delete (usually highly restricted)\r\n    APPROVE,    // approve/endorse (e.g. claim decision)\r\n    SHARE       // explicitly share with another org/entity\r\n}\r\n\r\n/// @dev Global attributes for a subject (address).\r\nstruct SubjectAttrs {\r\n    Role role;\r\n    bytes32 orgId;          // e.g. insurer code, police department, hospital ID\r\n    bytes32 jurisdiction;   // e.g. region/country code\r\n    bool   isActive;\r\n}\r\n\r\n/// @dev Registered resource/evidence metadata (off-chain payload referenced by URI + hash).\r\nstruct Resource {\r\n    uint256 id;\r\n    bytes32 contentHash;    // hash of the off-chain object (video, PDF, JSON, etc.)\r\n    string  uri;            // pointer: s3://..., ipfs://..., https://..., etc.\r\n    bytes32 caseId;         // claims/case identifier\r\n    ResourceType rType;\r\n    uint8   sensitivity;    // 0 = low, higher = more sensitive (e.g. medical)\r\n    address owner;          // entity that registered it (insurer, court, etc.)\r\n    bool    exists;\r\n}\r\n\r\n/// @dev A single ABAC-style policy rule.\r\n///\r\n/// Matching semantics:\r\n///   - If a field is zero/wildcard (orgId, jurisdiction, caseId), it does not constrain.\r\n///   - If rType == GENERIC, any resource type is allowed (subject to sensitivity).\r\n///   - Resource.sensitivity must be <= maxSensitivity.\r\n///   - Time window enforced via notBefore / notAfter (0 = unbounded).\r\nstruct PolicyRule {\r\n    uint256 id;\r\n    Role role;              // subject role required\r\n    bytes32 orgId;          // optional: constrain to org\r\n    bytes32 jurisdiction;   // optional: constrain to jurisdiction\r\n    ResourceType rType;     // resource type (or GENERIC)\r\n    bytes32 caseId;         // optional: constrain to specific case\r\n    Action action;          // action this policy governs\r\n    uint8  maxSensitivity;  // maximum sensitivity allowed under this rule\r\n    uint64 notBefore;       // unix timestamp; 0 = no lower bound\r\n    uint64 notAfter;        // unix timestamp; 0 = no upper bound\r\n    bool   allow;           // for now only ALLOW rules are used\r\n    bool   active;\r\n}\r\n"
      }
    }
  }
}